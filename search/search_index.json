{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Django Environment Config \ud83d\udd17 1 pip install django-environment-config Documentation : https://mrthearman.github.io/django-environment-config/ Source Code : https://github.com/MrThearMan/django-environment-config/ Contributing : https://github.com/MrThearMan/django-environment-config/blob/main/CONTRIBUTING.md Inspired by django-configurations , this library aims to provide a simple way to configure settings for different environments in Django applications. For example, you might want to have different settings for local development compared to production, and different still when running automated tests or in checks in you CI.","title":"Home"},{"location":"#django-environment-config","text":"1 pip install django-environment-config Documentation : https://mrthearman.github.io/django-environment-config/ Source Code : https://github.com/MrThearMan/django-environment-config/ Contributing : https://github.com/MrThearMan/django-environment-config/blob/main/CONTRIBUTING.md Inspired by django-configurations , this library aims to provide a simple way to configure settings for different environments in Django applications. For example, you might want to have different settings for local development compared to production, and different still when running automated tests or in checks in you CI.","title":"Django Environment Config"},{"location":"basics/","text":"Basics \ud83d\udd17 Environments are defined with a simple class-based configuration in the settings.py module. 1 2 3 4 from env_config import Environment class Example ( Environment ): DEBUG = True The Environment must be selected by setting the DJANGO_SETTINGS_ENVIRONMENT environment variable to the name of the class. If the environment variable is not set, an exception will be raised, since the library will not be able to determine which environment should be used. 1 DJANGO_SETTINGS_ENVIRONMENT = Example python manage.py runserver Similarly to the django-configurations library, the selected Environment's upper-case class attributes will be added as the module level global variables in the module where the environment is defined. This happens immidiately after the Environment class is defined as part of the class creation process. 1 2 3 4 5 6 7 8 9 10 11 12 from env_config import Environment class Example ( Environment ): DEBUG = True # These will not be used not_global = None _NOT_GLOBAL = None # Exists immidiately after Example is defined, # given `DJANGO_SETTINGS_ENVIRONMENT=Example` print ( DEBUG ) However, this library's implementation is much simpler and doesn't require any additional configuration or setup. Here is the magic behind the scenes from env_config.base.Environment.setup : 1 2 3 4 5 # Inspect the call stack to find the module where the environment is defined stack = inspect . stack () module_globals = stack [ stack_level ] . frame . f_globals # Update the module's global variables with the environment's loaded settings module_globals . update ( ** settings ) Of course, one should be a little careful that this does not override any existing global variables in the module.","title":"Basics"},{"location":"basics/#basics","text":"Environments are defined with a simple class-based configuration in the settings.py module. 1 2 3 4 from env_config import Environment class Example ( Environment ): DEBUG = True The Environment must be selected by setting the DJANGO_SETTINGS_ENVIRONMENT environment variable to the name of the class. If the environment variable is not set, an exception will be raised, since the library will not be able to determine which environment should be used. 1 DJANGO_SETTINGS_ENVIRONMENT = Example python manage.py runserver Similarly to the django-configurations library, the selected Environment's upper-case class attributes will be added as the module level global variables in the module where the environment is defined. This happens immidiately after the Environment class is defined as part of the class creation process. 1 2 3 4 5 6 7 8 9 10 11 12 from env_config import Environment class Example ( Environment ): DEBUG = True # These will not be used not_global = None _NOT_GLOBAL = None # Exists immidiately after Example is defined, # given `DJANGO_SETTINGS_ENVIRONMENT=Example` print ( DEBUG ) However, this library's implementation is much simpler and doesn't require any additional configuration or setup. Here is the magic behind the scenes from env_config.base.Environment.setup : 1 2 3 4 5 # Inspect the call stack to find the module where the environment is defined stack = inspect . stack () module_globals = stack [ stack_level ] . frame . f_globals # Update the module's global variables with the environment's loaded settings module_globals . update ( ** settings ) Of course, one should be a little careful that this does not override any existing global variables in the module.","title":"Basics"},{"location":"config/","text":"Configuration \ud83d\udd17 Loading the Environment \ud83d\udd17 The library supports configurable settings using \"value descriptors\" . These descriptors are used to define settings that can change their values based on a .env file or environment variables. By default, Environment-classes will look for a .env file from the current working directory up to the root using the python-dotenv library. 1 2 3 4 from env_config import Environment , values class Example ( Environment ): DEBUG = values . BooleanValue () In case you want to use environment variables instead: 1 2 3 4 from env_config import Environment , values class Example ( Environment , use_environ = True ): DEBUG = values . BooleanValue () If a value matching the setting's name is found from the configured location, it will be used to set the value of the setting, given the specific descriptor is able to convert it to the type it expects. You can also set the path for the .env file directly if you wish. 1 2 3 4 from env_config import Environment , values class Example ( Environment , dotenv_path = \"/path/to/.env\" ): DEBUG = values . BooleanValue () Or you can disable the loading the .env file altogether. 1 2 3 4 from env_config import Environment , values class Example ( Environment , dotenv_path = None ): DEBUG = values . BooleanValue () However, doing this with the above configuration will raise an error, since we cannot determine the value for DEBUG . Similarly, an error would be raised if the .env if loaded, but it does not contain a matching value for the setting. Therefore, we must set a default value in the descriptor for these cases. 1 2 3 4 from env_config import Environment , values class Example ( Environment ): DEBUG = values . BooleanValue ( default = False ) The default value can also be None , but note that doing this will also skip the normal value conversion based on the descriptor type. In case the name of the setting in the .env file or environment is different from the name of the setting in the Environment class, you can specify the name of the matching setting in the descriptor using env_name . 1 2 3 4 from env_config import Environment , values class Example ( Environment ): DEBUG = values . BooleanValue ( env_name = \"DJANGO_DEBUG_MODE\" ) Setting env_name to None will make the descriptor always use the default value, even if the loaded environment contains a value for the setting. This can be useful if the value descriptor contains some useful validation or conversion logic that you want to use when setting the value. Value Descriptors \ud83d\udd17 Value \ud83d\udd17 The base class for all value descriptors. This is an abstract class that can't be used directly. All subclasses must implement the convert method, and can be initialized with the following arguments: default : The default value for the setting. If not set, a value for the setting must be found from the .env file or environment, or an exception will be raised. env_name : The name of the setting in the .env file or environment. If not set, the name of the setting in the Environment class is used. If set to None , the descriptor will always use the default value. StringValue \ud83d\udd17 A value descriptor for string values. The convert method will return the value as is. BooleanValue \ud83d\udd17 A value descriptor for boolean values. The convert method will return True if the value is one of the following (case-insensitive): yes , y , true , or 1 . Conversely, the method will return False if the value is one of the following (case-insensitive): no , n , false , 0 or \"\" . Otherwise, an exception will be raised. IntegerValue \ud83d\udd17 A value descriptor for integer values. The convert method will return the value as an integer if it can be converted. Otherwise, an exception will be raised. PositiveIntegerValue \ud83d\udd17 A value descriptor for positive integer values. The convert method will return the value as an integer if it can be converted and is greater than zero. Otherwise, an exception will be raised. FloatValue \ud83d\udd17 A value descriptor for float values. The convert method will return the value as a float if it can be converted. Otherwise, an exception will be raised. DecimalValue \ud83d\udd17 A value descriptor for decimal values. The convert method will return the value as a decimal if it can be converted. Otherwise, an exception will be raised. ImportStringValue \ud83d\udd17 A value descriptor for string values that should be importable. The convert method will return the imported value if it can be imported. Otherwise, an exception will be raised. SequenceValue \ud83d\udd17 An abstract value descriptor for sequences like lists, tuples, and sets. Cannot be used directly. Accepts the following additional arguments: child : A value descriptor to use for the list items. If not set, the items will be returned as strings. delimiter : The delimiter to use when splitting the string into a list. Defaults to , . ListValue \ud83d\udd17 A SequenceValue descriptor for lists. The convert method will return the value as a list if it can be converted. Otherwise, an exception will be raised. TupleValue \ud83d\udd17 A SequenceValue descriptor for tuples. The convert method will return the value as a tuple if it can be converted. Otherwise, an exception will be raised. SetValue \ud83d\udd17 A SequenceValue descriptor for sets. The convert method will return the value as a sets if it can be converted. Otherwise, an exception will be raised. MappingValue \ud83d\udd17 An abstract value descriptor for sequences like dicts. Cannot be used directly. Accepts the following additional arguments: child : A value descriptor to use for the dict values. If not set, the items will be returned as strings. kv_delimiter : The delimiter to use when splitting items into keys and values. Defaults to = . item_delimiter : The delimiter to use when splitting the string list of key-value pairs. Defaults to ; . DictValue \ud83d\udd17 A MappingValue descriptor for dicts. The convert method will return the value as a dict if it can be converted. Otherwise, an exception will be raised. JsonValue \ud83d\udd17 A value descriptor for JSON values. The convert method will return the value as a valid JSON value if it can be converted. Otherwise, an exception will be raised. EmailValue \ud83d\udd17 A value descriptor for email values. The convert method will return the value as is if it's a valid email address. Otherwise, an exception will be raised. URLValue \ud83d\udd17 A value descriptor for URL values. The convert method will return the value as is if it's a valid URL. Otherwise, an exception will be raised. IPValue \ud83d\udd17 A value descriptor for IP address values. The convert method will return the value as is if it's a valid IP address. Otherwise, an exception will be raised. RegexValue \ud83d\udd17 A value descriptor for values that should match a regular expression. Accepts the following additional arguments: regex : The regular expression pattern to match. The convert method will return the value as is if it matches the regular expression. Otherwise, an exception will be raised. PathValue \ud83d\udd17 A value descriptor for directory path values. Accepts the following additional arguments: check_exists : Whether to check if the path exists or not. Defaults to True . create_if_missing : If True , create the path if it doesn't exist. Defaults to False . mode : The mode to use when creating the path if it doesn't exist. Defaults to 0o777 . The convert method will return the value as is if it's a valid directory path. Otherwise, an exception will be raised. DatabaseURLValue \ud83d\udd17 Requires the db extra dependency to be installed. 1 pip install django-environment-config[db] A value descriptor for configuring the DATABASES setting in Django. It uses the dj_database_url library to parse the setting from a DATABASE_URL environment variable. See the library for more details. The convert method will convert the value to a dictionary that can be used as the DATABASES setting, if it can be parsed. Otherwise, an exception will be raised. CacheURLValue \ud83d\udd17 Requires the cache extra dependency to be installed. 1 pip install django-environment-config[cache] A value descriptor for configuring the CACHES setting in Django. It uses the django_cache_url library to parse the setting from a CACHE_URL environment variable. See the library for more details. The convert method will convert the value to a dictionary that can be used as the CACHES setting, if it can be parsed. Otherwise, an exception will be raised. Computed properties \ud83d\udd17 In addition to value descriptors and regular class attributes, you can also use classproperties to define computed settings. This can be useful if the setting requires values from other settings. 1 2 3 4 5 6 7 8 9 from env_config import Environment , values from env_config.decorators import classproperty class Example ( Environment ): DEBUG = values . BooleanValue ( default = False ) @classproperty def LOG_LEVEL ( cls ): return \"DEBUG\" if cls . DEBUG else \"INFO\" Note that value descriptors are only bound to the environment values after the class is created, so if you try to use them in the class body before that, they will be plain classes, not descriptors. 1 2 3 4 5 6 7 8 from env_config import Environment , values class Example ( Environment ): DEBUG = values . BooleanValue ( default = False ) # Debug is still a BooleanValue instance, not a descriptor. # It will always be truthy, and so LOG_LEVEL will always be \"DEBUG\". LOG_LEVEL = \"DEBUG\" if DEBUG else \"INFO\" Configuration mixins \ud83d\udd17 Mixin-classes can be a useful way to reuse setting for multiple environments. Remember to add the mixin first, and the Environment second. 1 2 3 4 5 6 7 8 9 10 11 from env_config import Environment class Defaults : ADMINS = [] ... class Local ( Defaults , Environment ): pass class Prod ( Defaults , Environment ): pass Note, however, that mixins will not override values defined on the inheriting class. For this, use the overrides feature. Overrides \ud83d\udd17 For local development, one useful pattern for overriding settings is to provide a local_settings.py file that is ignored from versioning, and contains a mixin for overriding settings locally. This mixin can then be imported to the settings.py file, and added to the Environment using the overrides_from argument. This way, any settings defined in the mixin will be used, even if the same settings are also defined in the created Environment itself. 1 2 3 4 # local_settings.py class LocalOverrides : DEBUG = True 1 2 3 4 5 6 7 8 9 10 11 12 13 # settings.py from env_config import Environment # Import mixin which is ignored from version control. # Catch import errors, since the mixin is not there in production. try : from local_settings import LocalOverrides except ImportError : class LocalOverrides : ... class Example ( Environment , overrides_from = LocalOverrides ): pass","title":"Configuration"},{"location":"config/#configuration","text":"","title":"Configuration"},{"location":"config/#loading-the-environment","text":"The library supports configurable settings using \"value descriptors\" . These descriptors are used to define settings that can change their values based on a .env file or environment variables. By default, Environment-classes will look for a .env file from the current working directory up to the root using the python-dotenv library. 1 2 3 4 from env_config import Environment , values class Example ( Environment ): DEBUG = values . BooleanValue () In case you want to use environment variables instead: 1 2 3 4 from env_config import Environment , values class Example ( Environment , use_environ = True ): DEBUG = values . BooleanValue () If a value matching the setting's name is found from the configured location, it will be used to set the value of the setting, given the specific descriptor is able to convert it to the type it expects. You can also set the path for the .env file directly if you wish. 1 2 3 4 from env_config import Environment , values class Example ( Environment , dotenv_path = \"/path/to/.env\" ): DEBUG = values . BooleanValue () Or you can disable the loading the .env file altogether. 1 2 3 4 from env_config import Environment , values class Example ( Environment , dotenv_path = None ): DEBUG = values . BooleanValue () However, doing this with the above configuration will raise an error, since we cannot determine the value for DEBUG . Similarly, an error would be raised if the .env if loaded, but it does not contain a matching value for the setting. Therefore, we must set a default value in the descriptor for these cases. 1 2 3 4 from env_config import Environment , values class Example ( Environment ): DEBUG = values . BooleanValue ( default = False ) The default value can also be None , but note that doing this will also skip the normal value conversion based on the descriptor type. In case the name of the setting in the .env file or environment is different from the name of the setting in the Environment class, you can specify the name of the matching setting in the descriptor using env_name . 1 2 3 4 from env_config import Environment , values class Example ( Environment ): DEBUG = values . BooleanValue ( env_name = \"DJANGO_DEBUG_MODE\" ) Setting env_name to None will make the descriptor always use the default value, even if the loaded environment contains a value for the setting. This can be useful if the value descriptor contains some useful validation or conversion logic that you want to use when setting the value.","title":"Loading the Environment"},{"location":"config/#value-descriptors","text":"","title":"Value Descriptors"},{"location":"config/#value","text":"The base class for all value descriptors. This is an abstract class that can't be used directly. All subclasses must implement the convert method, and can be initialized with the following arguments: default : The default value for the setting. If not set, a value for the setting must be found from the .env file or environment, or an exception will be raised. env_name : The name of the setting in the .env file or environment. If not set, the name of the setting in the Environment class is used. If set to None , the descriptor will always use the default value.","title":"Value"},{"location":"config/#stringvalue","text":"A value descriptor for string values. The convert method will return the value as is.","title":"StringValue"},{"location":"config/#booleanvalue","text":"A value descriptor for boolean values. The convert method will return True if the value is one of the following (case-insensitive): yes , y , true , or 1 . Conversely, the method will return False if the value is one of the following (case-insensitive): no , n , false , 0 or \"\" . Otherwise, an exception will be raised.","title":"BooleanValue"},{"location":"config/#integervalue","text":"A value descriptor for integer values. The convert method will return the value as an integer if it can be converted. Otherwise, an exception will be raised.","title":"IntegerValue"},{"location":"config/#positiveintegervalue","text":"A value descriptor for positive integer values. The convert method will return the value as an integer if it can be converted and is greater than zero. Otherwise, an exception will be raised.","title":"PositiveIntegerValue"},{"location":"config/#floatvalue","text":"A value descriptor for float values. The convert method will return the value as a float if it can be converted. Otherwise, an exception will be raised.","title":"FloatValue"},{"location":"config/#decimalvalue","text":"A value descriptor for decimal values. The convert method will return the value as a decimal if it can be converted. Otherwise, an exception will be raised.","title":"DecimalValue"},{"location":"config/#importstringvalue","text":"A value descriptor for string values that should be importable. The convert method will return the imported value if it can be imported. Otherwise, an exception will be raised.","title":"ImportStringValue"},{"location":"config/#sequencevalue","text":"An abstract value descriptor for sequences like lists, tuples, and sets. Cannot be used directly. Accepts the following additional arguments: child : A value descriptor to use for the list items. If not set, the items will be returned as strings. delimiter : The delimiter to use when splitting the string into a list. Defaults to , .","title":"SequenceValue"},{"location":"config/#listvalue","text":"A SequenceValue descriptor for lists. The convert method will return the value as a list if it can be converted. Otherwise, an exception will be raised.","title":"ListValue"},{"location":"config/#tuplevalue","text":"A SequenceValue descriptor for tuples. The convert method will return the value as a tuple if it can be converted. Otherwise, an exception will be raised.","title":"TupleValue"},{"location":"config/#setvalue","text":"A SequenceValue descriptor for sets. The convert method will return the value as a sets if it can be converted. Otherwise, an exception will be raised.","title":"SetValue"},{"location":"config/#mappingvalue","text":"An abstract value descriptor for sequences like dicts. Cannot be used directly. Accepts the following additional arguments: child : A value descriptor to use for the dict values. If not set, the items will be returned as strings. kv_delimiter : The delimiter to use when splitting items into keys and values. Defaults to = . item_delimiter : The delimiter to use when splitting the string list of key-value pairs. Defaults to ; .","title":"MappingValue"},{"location":"config/#dictvalue","text":"A MappingValue descriptor for dicts. The convert method will return the value as a dict if it can be converted. Otherwise, an exception will be raised.","title":"DictValue"},{"location":"config/#jsonvalue","text":"A value descriptor for JSON values. The convert method will return the value as a valid JSON value if it can be converted. Otherwise, an exception will be raised.","title":"JsonValue"},{"location":"config/#emailvalue","text":"A value descriptor for email values. The convert method will return the value as is if it's a valid email address. Otherwise, an exception will be raised.","title":"EmailValue"},{"location":"config/#urlvalue","text":"A value descriptor for URL values. The convert method will return the value as is if it's a valid URL. Otherwise, an exception will be raised.","title":"URLValue"},{"location":"config/#ipvalue","text":"A value descriptor for IP address values. The convert method will return the value as is if it's a valid IP address. Otherwise, an exception will be raised.","title":"IPValue"},{"location":"config/#regexvalue","text":"A value descriptor for values that should match a regular expression. Accepts the following additional arguments: regex : The regular expression pattern to match. The convert method will return the value as is if it matches the regular expression. Otherwise, an exception will be raised.","title":"RegexValue"},{"location":"config/#pathvalue","text":"A value descriptor for directory path values. Accepts the following additional arguments: check_exists : Whether to check if the path exists or not. Defaults to True . create_if_missing : If True , create the path if it doesn't exist. Defaults to False . mode : The mode to use when creating the path if it doesn't exist. Defaults to 0o777 . The convert method will return the value as is if it's a valid directory path. Otherwise, an exception will be raised.","title":"PathValue"},{"location":"config/#databaseurlvalue","text":"Requires the db extra dependency to be installed. 1 pip install django-environment-config[db] A value descriptor for configuring the DATABASES setting in Django. It uses the dj_database_url library to parse the setting from a DATABASE_URL environment variable. See the library for more details. The convert method will convert the value to a dictionary that can be used as the DATABASES setting, if it can be parsed. Otherwise, an exception will be raised.","title":"DatabaseURLValue"},{"location":"config/#cacheurlvalue","text":"Requires the cache extra dependency to be installed. 1 pip install django-environment-config[cache] A value descriptor for configuring the CACHES setting in Django. It uses the django_cache_url library to parse the setting from a CACHE_URL environment variable. See the library for more details. The convert method will convert the value to a dictionary that can be used as the CACHES setting, if it can be parsed. Otherwise, an exception will be raised.","title":"CacheURLValue"},{"location":"config/#computed-properties","text":"In addition to value descriptors and regular class attributes, you can also use classproperties to define computed settings. This can be useful if the setting requires values from other settings. 1 2 3 4 5 6 7 8 9 from env_config import Environment , values from env_config.decorators import classproperty class Example ( Environment ): DEBUG = values . BooleanValue ( default = False ) @classproperty def LOG_LEVEL ( cls ): return \"DEBUG\" if cls . DEBUG else \"INFO\" Note that value descriptors are only bound to the environment values after the class is created, so if you try to use them in the class body before that, they will be plain classes, not descriptors. 1 2 3 4 5 6 7 8 from env_config import Environment , values class Example ( Environment ): DEBUG = values . BooleanValue ( default = False ) # Debug is still a BooleanValue instance, not a descriptor. # It will always be truthy, and so LOG_LEVEL will always be \"DEBUG\". LOG_LEVEL = \"DEBUG\" if DEBUG else \"INFO\"","title":"Computed properties"},{"location":"config/#configuration-mixins","text":"Mixin-classes can be a useful way to reuse setting for multiple environments. Remember to add the mixin first, and the Environment second. 1 2 3 4 5 6 7 8 9 10 11 from env_config import Environment class Defaults : ADMINS = [] ... class Local ( Defaults , Environment ): pass class Prod ( Defaults , Environment ): pass Note, however, that mixins will not override values defined on the inheriting class. For this, use the overrides feature.","title":"Configuration mixins"},{"location":"config/#overrides","text":"For local development, one useful pattern for overriding settings is to provide a local_settings.py file that is ignored from versioning, and contains a mixin for overriding settings locally. This mixin can then be imported to the settings.py file, and added to the Environment using the overrides_from argument. This way, any settings defined in the mixin will be used, even if the same settings are also defined in the created Environment itself. 1 2 3 4 # local_settings.py class LocalOverrides : DEBUG = True 1 2 3 4 5 6 7 8 9 10 11 12 13 # settings.py from env_config import Environment # Import mixin which is ignored from version control. # Catch import errors, since the mixin is not there in production. try : from local_settings import LocalOverrides except ImportError : class LocalOverrides : ... class Example ( Environment , overrides_from = LocalOverrides ): pass","title":"Overrides"},{"location":"hooks/","text":"Hooks \ud83d\udd17 The Environment-class provides a few hooks that can be used to add logic to the initialization of the environment, or modify its behavior. pre-setup \ud83d\udd17 This hook is called before the settings have been determined, but after the environment has been loaded. 1 2 3 4 5 6 7 from env_config import Environment class Example ( Environment ): @classmethod def pre_setup ( cls ): ... post-setup \ud83d\udd17 This hook is called after the settings have been determined. 1 2 3 4 5 6 7 from env_config import Environment class Example ( Environment ): @classmethod def post_setup ( cls ) -> None : ... load_dotenv \ud83d\udd17 This method is used to load the .env file. By default, the library uses the python-dotenv library to load the file. You can override this method to provide your own implementation. It should return a mapping of the environment variables, where the keys and values are strings. 1 2 3 4 5 6 7 8 from env_config import Environment from dotenv.main import StrPath class Example ( Environment ): @staticmethod def load_dotenv ( * , dotenv_path : StrPath | None = None ) -> dict [ str , str ]: ...","title":"Hooks"},{"location":"hooks/#hooks","text":"The Environment-class provides a few hooks that can be used to add logic to the initialization of the environment, or modify its behavior.","title":"Hooks"},{"location":"hooks/#pre-setup","text":"This hook is called before the settings have been determined, but after the environment has been loaded. 1 2 3 4 5 6 7 from env_config import Environment class Example ( Environment ): @classmethod def pre_setup ( cls ): ...","title":"pre-setup"},{"location":"hooks/#post-setup","text":"This hook is called after the settings have been determined. 1 2 3 4 5 6 7 from env_config import Environment class Example ( Environment ): @classmethod def post_setup ( cls ) -> None : ...","title":"post-setup"},{"location":"hooks/#load_dotenv","text":"This method is used to load the .env file. By default, the library uses the python-dotenv library to load the file. You can override this method to provide your own implementation. It should return a mapping of the environment variables, where the keys and values are strings. 1 2 3 4 5 6 7 8 from env_config import Environment from dotenv.main import StrPath class Example ( Environment ): @staticmethod def load_dotenv ( * , dotenv_path : StrPath | None = None ) -> dict [ str , str ]: ...","title":"load_dotenv"},{"location":"testing/","text":"Testing \ud83d\udd17 This library provides integration with the pytest testing framework. The integration provides an easy way to configure the used Environment when running tests by setting the DJANGO_SETTINGS_ENVIRONMENT configuration variable. 1 2 [pytest] DJANGO_SETTINGS_ENVIRONMENT = Example Alternatively, you can use do the same in a pyproject.toml file: 1 2 [tool.pytest.ini_options] DJANGO_SETTINGS_ENVIRONMENT = \"Example\"","title":"Testing"},{"location":"testing/#testing","text":"This library provides integration with the pytest testing framework. The integration provides an easy way to configure the used Environment when running tests by setting the DJANGO_SETTINGS_ENVIRONMENT configuration variable. 1 2 [pytest] DJANGO_SETTINGS_ENVIRONMENT = Example Alternatively, you can use do the same in a pyproject.toml file: 1 2 [tool.pytest.ini_options] DJANGO_SETTINGS_ENVIRONMENT = \"Example\"","title":"Testing"}]}